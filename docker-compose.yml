services:
  postgres_app:
    image: postgres:16
    container_name: postgres_app
    restart: unless-stopped
    environment:
      - POSTGRES_DB=${PGAPP_DB_NAME}
      - POSTGRES_USER=${PGAPP_DB_USER}
      - POSTGRES_PASSWORD=${PGAPP_DB_PASSWORD}
    ports:
      - "${PGAPP_DB_PORT}:5432"
    volumes:
      - ${PGAPP_DB_VOLUME}:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d app_db"]
      interval: 30s
      timeout: 5s
      retries: 10

  postgres_temporal:
    image: postgres:16
    container_name: postgres_temporal
    restart: unless-stopped
    environment:
      - POSTGRES_DB=${PGT_DB_NAME}
      - POSTGRES_USER=${PGT_DB_USER}
      - POSTGRES_PASSWORD=${PGT_DB_PASSWORD}
    ports:
      - "${PGT_DB_PORT}:5432"
    volumes:
      - ${PGT_DB_VOLUME}:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d temporal"]
      interval: 30s
      timeout: 5s
      retries: 10

  temporal:
    image: temporalio/auto-setup:latest
    container_name: temporal
    restart: unless-stopped
    depends_on:
      postgres_temporal:
        condition: service_healthy
    environment:
      - DB=postgres12
      - DB_PORT=5432
      - POSTGRES_SEEDS=postgres_temporal
      - POSTGRES_USER=${PGT_DB_USER}
      - POSTGRES_PWD=${PGT_DB_PASSWORD}
      - DBNAME=${PGT_DB_NAME}
      - VISIBILITY_DBNAME=temporal_visibility
      - DEFAULT_NAMESPACE=${TMP_DEFAULT_NAMESPACE}
      - DEFAULT_NAMESPACE_RETENTION=168h
      - SKIP_SCHEMA_SETUP=false
      - LOG_LEVEL=info
    ports:
      - "${TEMPORAL_PORT}:7233"

  temporal-ui:
    image: temporalio/ui:latest
    container_name: temporal-ui
    restart: unless-stopped
    depends_on:
      - temporal
    environment:
      - TEMPORAL_ADDRESS=temporal:7233
      - TEMPORAL_DEFAULT_NAMESPACE=default
    ports:
      - "${TEMPORAL_UI_PORT}:8080"

  minio:
    image: minio/minio:latest
    container_name: minio
    restart: unless-stopped
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    ports:
      - "${MINIO_PORT}:9000"
      - "${MINIO_CONSOLE_PORT}:9001"
    volumes:
      - ${MINIO_DATA_PATH}:/data

  minio-client:
    image: minio/mc:latest
    container_name: minio-client
    depends_on:
      - minio
    entrypoint: >
      /bin/sh -c "
      mc alias set local http://minio:9000 ${MINIO_ROOT_USER} ${MINIO_ROOT_PASSWORD} &&
      tail -f /dev/null
      "

  seaweed-master:
    image: chrislusf/seaweedfs:latest
    container_name: seaweed-master
    profiles: ["seaweed"]
    command: master -ip=seaweed-master -port=9333
    ports:
      - "${SEAWEED_MASTER_PORT}:9333"
    volumes:
      - ${SEAWEED_DATA_PATH}/master:/data

  seaweed-volume:
    image: chrislusf/seaweedfs:latest
    container_name: seaweed-volume
    profiles: ["seaweed"]
    command: volume -mserver="seaweed-master:9333" -port=8080 -ip=seaweed-volume -dir=/data
    depends_on:
      - seaweed-master
    ports:
      - "${SEAWEED_VOLUME_PORT}:8080"
    volumes:
      - ${SEAWEED_DATA_PATH}/volume:/data
# 7:17 когда говорят о загрузке на S3, почему-то редко вспоминают такую штуку, как подписанные URL-ы.
# Суть в том, что бекенд с помощью своих секретов от S3 подписывает специально сформированный URL, отдаёт
# его фронтенду, а фронт уже сам туда заливает нужный файл. Это экономит ресурсы бекенда и время пользователя.
# При этом у подписи есть срок жизнь (до семи дней), то есть, URL сам отключается и не даёт заменить данные.
# Плюс можно ограничить размер заливаемого файла, чтобы особо ушлые пользователи не слили весь ваш бюджет на хранение.
# Плюс в тот же URL можно зашивать кастомные теги, которые будут проставлены на файл после заливки
# (и пользователь не сможет их подменить, потому что они защищиены подписью).
# В общем, очень недооценённая функциональность.
  seaweed-filer:
    image: chrislusf/seaweedfs:latest
    container_name: seaweed-filer
    profiles: ["seaweed"]
    command: filer -master="seaweed-master:9333" -ip=seaweed-filer -port=8888
    depends_on:
      - seaweed-master
      - seaweed-volume
    ports:
      - "${SEAWEED_FILER_PORT}:8888"
    volumes:
      - ${SEAWEED_DATA_PATH}/filer:/data

  seaweed-s3:
    image: chrislusf/seaweedfs:latest
    container_name: seaweed-s3
    profiles: ["seaweed"]
    command: s3 -filer="seaweed-filer:8888" -port=8333
    depends_on:
      - seaweed-filer
    ports:
      - "${SEAWEED_S3_PORT}:8333"
  
  portainer:
      image: portainer/portainer-ce:latest
      container_name: portainer
      ports:
        - "${PORTAINER_PORT}:9443"
      volumes:
        - /var/run/docker.sock:/var/run/docker.sock
        - ${PD_DATA_PATH}:/data

  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest

  keydb:
    image: eqalpha/keydb:latest
    container_name: keydb
    ports:
      - "6379:6379"
    command: keydb-server --requirepass password --appendonly yes